pragma solidity ^0.4.24;

import "../contrib/EIP/eip777/contracts/ERC777ERC20BaseToken.sol";
import "../lifecycle/Pausable.sol";

/// @dev Adds a Pausable modifier override to all functions that modify state
contract PausableToken is ERC777ERC20BaseToken, Pausable {

  event Pause();
  event Unpause();

  bool public paused;

  constructor(
    string _name,
    string _symbol,
    uint256 _granularity,
    address[] _defaultOperators
  ) ERC777ERC20BaseToken(_name, _symbol, _granularity, _defaultOperators) {  }


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused, "You cannot use this function when the contract is paused");
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused, "You cannot use this function when the contract is un-paused");
    _;
  }


  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() public onlyOwner {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() public onlyOwner {
    paused = false;
    emit Unpause();
  }

  /// @notice ERC20 backwards compatible transfer.
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be transferred
  /// @return `true`, if the transfer can't be done, it should fail.
  function transfer(address _to, uint256 _value) public erc20 whenNotPaused returns (bool success) {
    return super.transfer(_to, _value);
  }

  /// @notice ERC20 backwards compatible transferFrom.
  /// @param _from The address holding the tokens being transferred
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be transferred
  /// @return `true`, if the transfer can't be done, it should fail.
  function transferFrom(address _from, address _to, uint256 _value) public erc20 whenNotPaused returns (bool success) {
    return super.transferFrom(_from, _to, _value);
  }

  /// @notice ERC20 backwards compatible approve.
  ///  `msg.sender` approves `_spender` to spend `_value` tokens on its behalf.
  /// @param _spender The address of the account able to transfer the tokens
  /// @param _value The amount of tokens to be approved for transfer
  /// @return `true`, if the approve can't be done, it should fail.
  function approve(address _spender, uint256 _value) public erc20 whenNotPaused returns (bool success) {
    return super.approve(_spender, _value);
  }

  /// @notice Send `_value` amount of tokens to address `_to` passing `_userData` to the recipient
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be sent
  function send(address _to, uint256 _value, bytes _userData) public whenNotPaused {
    super.send(_to, _value, _userData); // solium-disable-line security/no-send
  }

  /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.
  /// @param _operator The operator that wants to be Authorized
  //todo jaycen pretty sure overloads dont work so calling the following is impossible
  function authorizeOperator(address _operator) public whenNotPaused {
    super.authorizeOperator(_operator);
  }

  /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.
  /// @param _operator The operator that wants to be Revoked
  function revokeOperator(address _operator) public whenNotPaused {
    super.revokeOperator(_operator);
  }

  /// @notice Send `_value` amount of tokens on behalf of the address `from` to the address `to`.
  /// @param _from The address holding the tokens being sent
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be sent
  /// @param _userData Data generated by the user to be sent to the recipient
  /// @param _operatorData Data generated by the operator to be sent to the recipient
  function operatorSend(
    // address _operator,
    address _from,
    address _to,
    uint256 _value,
    bytes _userData,
    bytes _operatorData
  ) public whenNotPaused {
    super.operatorSend(
      _from,
      _to,
      _value,
      _userData,
      _operatorData
    );
  }

  /// @notice Burns `_value` tokens from `_tokenHolder`
  ///  Sample burn function to showcase the use of the `Burnt` event.
  /// @param _data Data generated by the user to be used during burn
  /// @param _amount The quantity of tokens to burn
  function burn(uint256 _amount, bytes _data) public onlyOwner {
    super.burn(_amount, _data);
  }

}