pragma solidity ^0.4.24;
import "../EIP777/UnstructuredTokenBase.sol";


/// @dev Adds a Pausable modifier override to all functions that modify state
contract PausableToken is UnstructuredTokenBase {

  event Pause();
  event Unpause();

  bool public paused = false;

  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused, "You cannot use this function when the contract is paused");
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused, "You cannot use this function when the contract is un-paused");
    _;
  }

  constructor() UnstructuredTokenBase() public {
    /*Delegate constructor*/
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() public onlyOwner whenNotPaused {
    paused = true;
    emit Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() public onlyOwner whenPaused {
    paused = false;
    emit Unpause();
  }

  function setContractRegistry(address _contractRegistryAddr) public onlyOwner whenNotPaused {
    super.setContractRegistry(_contractRegistryAddr);
  }

  /// @notice Disables the ERC-20 interface. This function can only be called
  ///  by the owner.
  function disableERC20() public onlyOwner whenNotPaused {
    super.disableERC20();
  }

  /// @notice Re enables the ERC-20 interface. This function can only be called
  ///  by the owner.
  function enableERC20() public onlyOwner whenNotPaused {
    super.enableERC20();
  }

  /// @notice ERC20 backwards compatible transfer.
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be transferred
  /// @return `true`, if the transfer can't be done, it should fail.
  function transfer(address _to, uint256 _value) public erc20 whenNotPaused returns (bool success) {
    return super.transfer(_to, _value);
  }

  /// @notice ERC20 backwards compatible transferFrom.
  /// @param _from The address holding the tokens being transferred
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be transferred
  /// @return `true`, if the transfer can't be done, it should fail.
  function transferFrom(address _from, address _to, uint256 _value) public erc20 whenNotPaused returns (bool success) {
    return super.transferFrom(_from, _to, _value);
  }

  /// @notice ERC20 backwards compatible approve.
  ///  `msg.sender` approves `_spender` to spend `_value` tokens on its behalf.
  /// @param _spender The address of the account able to transfer the tokens
  /// @param _value The amount of tokens to be approved for transfer
  /// @return `true`, if the approve can't be done, it should fail.
  function approve(address _spender, uint256 _value) public erc20 whenNotPaused returns (bool success) {
    return super.approve(_spender, _value);
  }

  /// @notice Send `_value` amount of tokens to address `_to`
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be sent
  function send(address _to, uint256 _value) public whenNotPaused {
    super.send(_to, _value); // solium-disable-line security/no-send
  }

  /// @notice Send `_value` amount of tokens to address `_to` passing `_userData` to the recipient
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be sent
  function send(address _to, uint256 _value, bytes _userData) public whenNotPaused {
    super.send(_to, _value, _userData); // solium-disable-line security/no-send
  }

  /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.
  /// @param _operator The operator that wants to be Authorized
  //todo jaycen pretty sure overloads dont work so calling the following is impossible
  function authorizeOperator(address _operator) public whenNotPaused {
    super.authorizeOperator(_operator);
  }

  /// @notice Authorize a third party `_operator` to manage [only some] (send) `msg.sender`'s tokens.
  /// @param _operator The operator that wants to be Authorized
  function authorizeOperator(address _operator, uint256 _value) public whenNotPaused {
    super.authorizeOperator(_operator, _value);
  }

  /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.
  /// @param _operator The operator that wants to be Revoked
  function revokeOperator(address _operator) public whenNotPaused {
    super.revokeOperator(_operator);
  }

  /// @notice Send `_value` amount of tokens on behalf of the address `from` to the address `to`.
  /// @param _from The address holding the tokens being sent
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be sent
  /// @param _userData Data generated by the user to be sent to the recipient
  /// @param _operatorData Data generated by the operator to be sent to the recipient
  function operatorSend(
    address _operator,
    address _from,
    address _to,
    uint256 _value,
    bytes _userData,
    bytes _operatorData
  ) public whenNotPaused {
    super.operatorSend(
      _operator,
      _from,
      _to,
      _value,
      _userData,
      _operatorData
    );
  }

  /// @notice Send `_value` amount of tokens on behalf of the address `from` to the address `to`.
  /// @param _from The address holding the tokens being sent
  /// @param _to The address of the recipient
  /// @param _value The amount of tokens to be sent
  /// @param _userData Data generated by the user to be sent to the recipient
  /// @param _operatorData Data generated by the operator to be sent to the recipient
  function operatorSend(
    address _from,
    address _to,
    uint256 _value,
    bytes _userData,
    bytes _operatorData
  ) public whenNotPaused {
    super.operatorSend(
      msg.sender,
      _from,
      _to,
      _value,
      _userData,
      _operatorData
    );
  }

  /// @notice Burns `_value` tokens from `_tokenHolder`
  ///  Sample burn function to showcase the use of the `Burnt` event.
  /// @param _tokenHolder The address that will lose the tokens
  /// @param _value The quantity of tokens to burn
  function burn(address _tokenHolder, uint256 _value) public onlyOwner whenNotPaused {
    super.burn(_tokenHolder, _value);
  }

  /// @notice Generates `_value` tokens to be assigned to `_tokenHolder`
  /// @param _tokenHolder The address that will be assigned the new tokens
  /// @param _value The quantity of tokens generated
  /// @param _operatorData Data that will be passed to the recipient as a first transfer
  /// XXX: DO NOT SHIP TO PRODUCTION (use following instead :  function ownerMint(address _tokenHolder, uint256 _value, bytes _operatorData) public onlyOwner
  function mint(address _tokenHolder, uint256 _value, bytes _operatorData) public whenNotPaused {
    super.mint(_tokenHolder, _value, _operatorData);
  }
}